[![gcc-11](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/gcc-11.yaml/badge.svg)](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/gcc-11.yaml)
[![gcc-12](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/gcc-12.yaml/badge.svg)](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/gcc-12.yaml)
[![clang-13](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/clang-13.yaml/badge.svg)](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/clang-13.yaml)
[![clang-14](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/clang-14.yaml/badge.svg)](https://github.com/gaggenwaschke/cpp-reflection/actions/workflows/clang-14.yaml)

# cpp-reflection

This library aims to allow for easy and automatic cpp reflection where possible. Since the C++ standard does not yet support
reflection, this library utilizes structured binding and abi calls to resolve structure names.

## type names

You can get the name of any type by:

```cpp
#include <reflection/names.hpp>

// This will yield "int":
auto& name = reflection::name<int>();
```

## list object member references

Any structure that can be structurally bound has its nameless member references automatically generated by:

```cpp
#include <reflection/member_object_references.hpp>

struct Car
{
    int speed;
    int fuel;
};

constexpr auto [speed_reference, fuel_reference] = reflection::get_member_object_references<Car>();

Car car1{20, 40};

// Will print 20.
std::cout << std::invoke(speed_reference, car1) << "\n";
// Will print 40.
std::cout << std::invoke(fuel_reference, car1) << "\n";

// You can also assign to them, drive slow!
std::invoke(speed_reference, car1) = 10;
```

## customize object member references

You can set custom object member references for a type by overloading the reflection::member_object_reference_list<> class:

```cpp
#include <reflection/member_object_references.hpp>

struct Car
{
    int speed;
    int fuel;
};

namespace reflection
{
    template <>
    struct member_object_reference_list<Car>
    {
        constexpr auto value = std::make_tuple(
            manual::member_object_reference{&Car::speed, "speed"},
            manual::member_object_reference{&Car::fuel, "fuel"});
    };
}
```

## named object member references

Customized member object references will give you the advantage of being able to use the names.
There is also a way to ensure at compile time, that the member object references you are using are all named:

```cpp
#include <reflection/member_object_references.hpp>

constexpr auto [speed_reference, fuel_reference] = reflection::get_named_member_object_references<Car>();

Car car{20, 40};

// Will print "speed".
std::cout << speed_reference.name() << "\n";
// Will print "fuel".
std::cout << fuel_reference.name() << "\n";

// And anything else you can do with non-named references!
```

## potential uses

A few uses of reflection are generic implementations of:
- serialization and deserialization
- application programming interfaces
- command line interfaces
